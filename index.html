<!doctype html>
<html lang="en">

<head>
  <!-- Basic Meta -->
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>Image Converter & Compressor – Convert, Compress & Optimize Images Online</title>
  <meta name="description"
    content="Easily convert and compress images online. Supports JPG, PNG, WEBP, AVIF, GIF. Reduce image size, change format, and optimize for web.">
  <meta name="keywords"
    content="image converter, image compressor, convert image online, compress image online, JPG to PNG, PNG to JPG, WEBP converter, AVIF converter, optimize images, reduce image size">
  <meta name="author" content="Your Name or Brand">
  <meta name="robots" content="index, follow">

  <!-- Canonical URL -->
  <link rel="canonical" href="https://yourdomain.com">

  <!-- Open Graph / Facebook -->
  <meta property="og:title" content="Image Converter & Compressor – Convert, Compress & Optimize Images Online">
  <meta property="og:description"
    content="Easily convert and compress images online. Supports JPG, PNG, WEBP, AVIF, GIF. Reduce image size, change format, and optimize for web.">
  <meta property="og:type" content="website">
  <meta property="og:url" content="https://yourdomain.com">
  <meta property="og:image" content="https://yourdomain.com/preview-image.jpg">
  <meta property="og:site_name" content="Image Converter & Compressor">

  <!-- Twitter Card -->
  <meta name="twitter:card" content="summary_large_image">
  <meta name="twitter:title" content="Image Converter & Compressor – Convert, Compress & Optimize Images Online">
  <meta name="twitter:description"
    content="Easily convert and compress images online. Supports JPG, PNG, WEBP, AVIF, GIF. Reduce image size, change format, and optimize for web.">
  <meta name="twitter:image" content="https://yourdomain.com/preview-image.jpg">
  <meta name="twitter:creator" content="@yourTwitterHandle">

  <!-- Favicons -->
  <link rel="icon" href="/favicon.ico" type="image/x-icon">
  <link rel="apple-touch-icon" sizes="180x180" href="/apple-touch-icon.png">
  <link rel="icon" type="image/png" sizes="32x32" href="/favicon-32x32.png">
  <link rel="icon" type="image/png" sizes="16x16" href="/favicon-16x16.png">

  <!-- Theme & Browser Hints -->
  <meta name="theme-color" content="#0b1020">
  <meta name="mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-capable" content="yes">
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">

  <!-- Preconnect / Preload for fonts -->
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800&display=swap"
    rel="stylesheet">
  <link rel="preload" as="font" href="https://fonts.gstatic.com/s/opensans/v34/mem8YaGs126MiZpBA-UFVZ0e.ttf"
    crossorigin>

  <!-- Performance / SEO hints -->
  <link rel="dns-prefetch" href="//fonts.googleapis.com">
  <link rel="dns-prefetch" href="//fonts.gstatic.com">

  <!-- Structured Data (JSON-LD) -->
  <script type="application/ld+json">
  {
    "@context": "https://schema.org",
    "@type": "WebApplication",
    "name": "Image Converter & Compressor",
    "url": "https://yourdomain.com",
    "applicationCategory": "ImageProcessingApplication",
    "description": "Convert and compress images online. Supports JPG, PNG, WEBP, AVIF, GIF. Reduce file size and optimize images for web.",
    "operatingSystem": "Web",
    "offers": {
      "@type": "Offer",
      "price": "0",
      "priceCurrency": "USD"
    }
  }
  </script>

  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Open+Sans:ital,wght@0,300..800;1,300..800display=swap"
    rel="stylesheet">
  <style>
    :root {
      --bg: #0b1020;
      --panel: #121934;
      --muted: #7f8ab6;
      --text: #e8ebff;
      --accent: #7aa2ff;
      --accent-2: #9d7aff;
      --danger: #ff6b6b;
      --radius: 16px;
    }

    * {
      box-sizing: border-box;
    }

    body {
      margin: 0;
      font-family: "Open Sans", sans-serif;
      background: linear-gradient(120deg, #252b40 0%, #0f1530 60%, #121934 100%);
      color: var(--text);
      min-height: 100vh;
      display: grid;
      place-items: start center;
      padding: 24px;
    }

    .app {
      width: min(1400px, 100%);
    }

    header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      gap: 16px;
      margin-bottom: 16px;
    }

    h1 {
      font-size: clamp(1.4rem, 1.1rem + 2vw, 2rem);
      margin: 0;
    }

    .card {
      background: radial-gradient(100% 140% at 0% 0%, #0e1530 0%, #0f1735 40%, #10183a 100%);
      border: 1px solid rgba(255, 255, 255, .06);
      border-radius: var(--radius);
      box-shadow: 0 10px 30px rgba(0, 0, 0, .35), inset 0 1px 0 rgba(255, 255, 255, .04);
      padding: 18px;
    }

    .grid {
      display: grid;
      gap: 16px;
      grid-template-columns: 1.2fr .8fr;
      align-items: start;
    }

    @media (max-width: 900px) {
      .grid {
        grid-template-columns: 1fr;
      }
    }

    .drop {
      border: 2px dashed rgba(122, 162, 255, .35);
      border-radius: calc(var(--radius) - 6px);
      padding: 22px;
      display: grid;
      place-items: center;
      text-align: center;
      gap: 8px;
      color: var(--muted);
      transition: 200ms ease;
      min-height: 140px;
    }

    .drop.dragover {
      border-color: var(--accent);
      background: rgba(122, 162, 255, .06);
      color: var(--text);
    }

    .controls {
      display: grid;
      gap: 12px;
    }

    .row {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 12px;
    }

    .row3 {
      display: grid;
      grid-template-columns: 1fr 1fr 1fr;
      gap: 12px;
    }

    label {
      display: grid;
      gap: 6px;
      font-size: .95rem;
      color: var(--muted);
    }

    input[type="number"],
    select,
    input[type="text"] {
      background: #0c1330;
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, .08);
      border-radius: 12px;
      padding: 10px 12px;
      outline: none;
    }

    input[type="range"] {
      width: 100%;
    }

    .muted {
      color: var(--muted);
      font-size: .9rem;
    }

    .btns {
      display: flex;
      flex-wrap: wrap;
      gap: 10px;
    }

    button {
      appearance: none;
      border: 0;
      cursor: pointer;
      color: white;
      font-weight: 600;
      padding: 10px 14px;
      border-radius: 12px;
      transition: 150ms ease;
      background: linear-gradient(135deg, var(--accent) 0%, var(--accent-2) 100%);
      box-shadow: 0 8px 20px rgba(125, 143, 255, .25);
    }

    button.secondary {
      background: #1a2250;
      color: var(--text);
      border: 1px solid rgba(255, 255, 255, .06);
      box-shadow: none;
    }

    button.danger {
      background: var(--danger);
    }

    button:disabled {
      opacity: .6;
      cursor: not-allowed;
    }

    .previews {
      display: grid;
      grid-template-columns: 1fr 1fr;
      gap: 16px;
    }

    @media (max-width: 900px) {
      .previews {
        grid-template-columns: 1fr;
      }
    }

    .preview {
      background: #0c1330;
      border: 1px solid rgba(255, 255, 255, .06);
      border-radius: 12px;
      overflow: hidden;
    }

    .preview header {
      display: flex;
      align-items: center;
      justify-content: space-between;
      padding: 10px 12px;
      border-bottom: 1px solid rgba(255, 255, 255, .06);
    }

    .preview .body {
      display: grid;
      place-items: center;
      padding: 12px;
    }

    .preview img {
      max-width: 100%;
      height: auto;
      display: block;
    }

    .stats {
      display: grid;
      grid-auto-flow: column;
      justify-content: start;
      gap: 14px;
      font-size: .9rem;
      color: var(--muted);
    }

    .badge {
      display: inline-flex;
      align-items: center;
      gap: 6px;
      padding: 6px 10px;
      border-radius: 999px;
      background: rgba(255, 255, 255, .06);
      color: var(--text);
      font-size: .85rem;
    }

    .mono {
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", "Courier New", monospace;
    }
  </style>

</head>

<body>
  <div class="app">
    <header>
      <h1>Image Converter & Compressor</h1>
      <div class="stats" id="stats-top"></div>
    </header>

    <div class="grid">
      <section class="card">
        <div id="drop" class="drop">
          <div>
            <div style="font-size:1.05rem; font-weight:700; color:#cdd6ff;">Drop image here or click to choose</div>
            <div class="muted">JPG • PNG • WEBP • AVIF • GIF (first frame)</div>
          </div>
          <input id="file" type="file" accept="image/*" style="display:none" />
        </div>

        <div class="previews" style="margin-top:16px">
          <div class="preview" id="origBox" hidden>
            <header>
              <strong>Original</strong>
              <span class="badge" id="origInfo">—</span>
            </header>
            <div class="body"><img id="origImg" alt="Original preview" /></div>
          </div>
          <div class="preview" id="outBox" hidden>
            <header>
              <strong>Output</strong>
              <span class="badge" id="outInfo">—</span>
            </header>
            <div class="body"><img id="outImg" alt="Output preview" /></div>
          </div>
        </div>
      </section>

      <aside class="card controls">
        <div class="row3">
          <label>Output format
            <select id="format">
              <option value="image/webp">WEBP (small, widely supported)</option>
              <option value="image/jpeg">JPEG</option>
              <option value="image/avif">AVIF (smallest, newer)</option>
              <option value="image/png">PNG (lossless)</option>
            </select>
          </label>
          <label>Quality
            <input id="quality" type="range" min="1" max="100" value="80" />
            <div class="muted">For lossy formats (JPEG/WEBP/AVIF)</div>
          </label>
          <label>Target size (KB)
            <input id="targetKB" type="number" min="1" step="1" placeholder="Optional e.g. 300" />
          </label>
        </div>

        <div class="row">
          <label>Max width (px)
            <input id="maxW" type="number" min="1" step="1" placeholder="Auto" />
          </label>
          <label>Max height (px)
            <input id="maxH" type="number" min="1" step="1" placeholder="Auto" />
          </label>
        </div>

        <div class="btns">
          <button id="btnConvert" disabled>Convert / Compress</button>
          <button id="btnTarget" class="secondary" disabled>Compress to Target KB</button>
          <button id="btnDownload" disabled>Download</button>
          <button id="btnClear" class="secondary">Clear</button>
        </div>

        <div class="muted" id="supportNote"></div>
      </aside>
    </div>
  </div>

  <script>
    const $ = (id) => document.getElementById(id);
    const drop = $("drop"), file = $("file");
    const origBox = $("origBox"), outBox = $("outBox");
    const origImg = $("origImg"), outImg = $("outImg");
    const origInfo = $("origInfo"), outInfo = $("outInfo");
    const statsTop = $("stats-top");

    const formatEl = $("format"), qualityEl = $("quality"), targetKBEl = $("targetKB");
    const maxWEl = $("maxW"), maxHEl = $("maxH");
    const btnConvert = $("btnConvert"), btnTarget = $("btnTarget"), btnDownload = $("btnDownload"), btnClear = $("btnClear");
    const supportNote = $("supportNote");

    let originalFile = null;
    let originalURL = null;
    let outputBlob = null;
    let outputName = "output";

    // Feature notes
    (function checkSupport() {
      const supportsAvif = (() => {
        try {
          const c = document.createElement('canvas');
          return c.toDataURL('image/avif').startsWith('data:image/avif');
        } catch { return false; }
      })();
      if (!supportsAvif) {
        const tip = document.createElement('div');
        tip.className = 'muted';
        tip.textContent = 'Note: AVIF export may not be supported in this browser.';
        supportNote.appendChild(tip);
      }
    })();

    // Drop zone interactions
    drop.addEventListener('click', () => file.click());
    drop.addEventListener('dragover', (e) => { e.preventDefault(); drop.classList.add('dragover'); });
    drop.addEventListener('dragleave', () => drop.classList.remove('dragover'));
    drop.addEventListener('drop', (e) => {
      e.preventDefault(); drop.classList.remove('dragover');
      const f = e.dataTransfer.files?.[0]; if (f) loadFile(f);
    });
    file.addEventListener('change', () => { const f = file.files?.[0]; if (f) loadFile(f); });

    function bytesToKB(b) { return (b / 1024).toFixed(1); }
    function extFromMime(m) { return ({ 'image/jpeg': 'jpg', 'image/png': 'png', 'image/webp': 'webp', 'image/avif': 'avif' }[m]) || 'img'; }

    async function loadFile(f) {
      clearOutput();
      originalFile = f;
      outputName = f.name.replace(/\.[^.]+$/, '') || 'image';
      if (originalURL) URL.revokeObjectURL(originalURL);
      originalURL = URL.createObjectURL(f);
      origImg.src = originalURL;
      origBox.hidden = false;
      origInfo.textContent = `${f.type || 'unknown'} • ${bytesToKB(f.size)} KB`;
      statsTop.textContent = `${f.name} — ${bytesToKB(f.size)} KB`;
      btnConvert.disabled = false;
      btnTarget.disabled = false;
    }

    function getMaxDims(imgW, imgH) {
      const mw = parseInt(maxWEl.value, 10);
      const mh = parseInt(maxHEl.value, 10);
      if (!mw && !mh) return { w: imgW, h: imgH };
      let w = imgW, h = imgH;
      if (mw && w > mw) { h = Math.round(h * (mw / w)); w = mw; }
      if (mh && h > mh) { w = Math.round(w * (mh / h)); h = mh; }
      return { w, h };
    }

    async function drawToCanvas(imgBitmap, w, h) {
      const canvas = document.createElement('canvas');
      canvas.width = w; canvas.height = h;
      const ctx = canvas.getContext('2d');
      ctx.drawImage(imgBitmap, 0, 0, w, h);
      return canvas;
    }

    function canvasToBlob(canvas, type, quality) {
      return new Promise((resolve, reject) => {
        canvas.toBlob(b => b ? resolve(b) : reject(new Error('Export failed')), type, quality);
      });
    }

    async function readImageBitmap(file) {
      const blob = file instanceof Blob ? file : new Blob([file]);
      const img = await createImageBitmap(blob);
      return img;
    }

    async function convertOnce(targetType, qualityPct) {
      if (!originalFile) return;
      const img = await readImageBitmap(originalFile);
      const { w, h } = getMaxDims(img.width, img.height);
      const canvas = await drawToCanvas(img, w, h);

      // PNG ignores quality; JPEG/WEBP/AVIF use 0..1
      const q = /image\/(jpeg|webp|avif)/.test(targetType) ? Math.min(Math.max(qualityPct / 100, 0.01), 1) : undefined;
      const blob = await canvasToBlob(canvas, targetType, q);
      return { blob, width: w, height: h };
    }

    async function convertToTargetKB(targetKB, targetType) {
      if (!originalFile) return;
      const startBitmap = await readImageBitmap(originalFile);
      let scale = 1.0;
      let low = 0.2, high = 0.95; // quality bounds for binary search
      const maxIter = 12;

      let w = startBitmap.width, h = startBitmap.height;
      // Respect user-specified max dims first
      const dims = getMaxDims(w, h); w = dims.w; h = dims.h;

      const lossy = /image\/(jpeg|webp|avif)/.test(targetType);
      if (!lossy) {
        // For PNG, we may need to downscale since quality param is ignored
        low = 1; high = 1; // fixed
      }

      for (let outer = 0; outer < 6; outer++) {
        let best = null;
        let l = low, r = high;
        for (let i = 0; i < maxIter; i++) {
          const q = lossy ? (l + r) / 2 : 1;
          const canvas = await drawToCanvas(startBitmap, Math.max(1, Math.round(w * scale)), Math.max(1, Math.round(h * scale)));
          const blob = await canvasToBlob(canvas, targetType, lossy ? q : undefined);
          const kb = blob.size / 1024;
          best = blob;
          if (!lossy) break; // can't binary-search quality for PNG
          if (kb > targetKB) {
            // too big -> lower quality
            r = q;
          } else {
            // too small -> raise quality
            l = q;
          }
          if (Math.abs(kb - targetKB) < 8) break; // close enough
        }
        if (best && best.size / 1024 <= targetKB + 8) return { blob: best, width: Math.round(w * scale), height: Math.round(h * scale) };
        // Still too big: reduce dimensions by 10% and try again
        scale *= 0.9;
        if (Math.round(w * scale) < 16 || Math.round(h * scale) < 16) break;
      }
      // Fallback: return last attempt at lowest quality/scale
      const canvas = await drawToCanvas(startBitmap, Math.max(1, Math.round(w * scale)), Math.max(1, Math.round(h * scale)));
      const blob = await canvasToBlob(canvas, targetType, lossy ? 0.2 : undefined);
      return { blob, width: Math.round(w * scale), height: Math.round(h * scale) };
    }

    function updateOutPreview(info) {
      const { blob, width, height } = info;
      outputBlob = blob;
      outImg.src = URL.createObjectURL(blob);
      outBox.hidden = false;
      outInfo.textContent = `${blob.type || 'unknown'} • ${bytesToKB(blob.size)} KB • ${width}×${height}`;
      btnDownload.disabled = false;
      const origKB = originalFile ? (originalFile.size / 1024) : 0;
      const pct = origKB ? Math.round(100 - (blob.size / originalFile.size) * 100) : 0;
      statsTop.textContent = `${originalFile.name} → ${bytesToKB(blob.size)} KB (${pct}% smaller)`;
    }

    btnConvert.addEventListener('click', async () => {
      try {
        btnConvert.disabled = true;
        const targetType = formatEl.value;
        const qualityPct = parseInt(qualityEl.value, 10) || 80;
        const res = await convertOnce(targetType, qualityPct);
        updateOutPreview(res);
      } catch (e) {
        alert('Conversion failed: ' + e.message);
      } finally {
        btnConvert.disabled = false;
      }
    });

    btnTarget.addEventListener('click', async () => {
      try {
        const kb = parseInt(targetKBEl.value, 10);
        if (!kb || kb <= 0) return alert('Enter a valid Target size (KB).');
        btnTarget.disabled = true;
        const res = await convertToTargetKB(kb, formatEl.value);
        updateOutPreview(res);
      } catch (e) {
        alert('Target compression failed: ' + e.message);
      } finally {
        btnTarget.disabled = false;
      }
    });

    btnDownload.addEventListener('click', () => {
      if (!outputBlob) return;
      const a = document.createElement('a');
      const ext = extFromMime(outputBlob.type || formatEl.value);
      a.href = URL.createObjectURL(outputBlob);
      a.download = `${outputName}.${ext}`;
      document.body.appendChild(a);
      a.click();
      setTimeout(() => { URL.revokeObjectURL(a.href); a.remove(); }, 1000);
    });

    btnClear.addEventListener('click', () => {
      originalFile = null; outputBlob = null;
      origBox.hidden = true; outBox.hidden = true;
      statsTop.textContent = '';
      btnConvert.disabled = true; btnTarget.disabled = true; btnDownload.disabled = true;
      if (originalURL) URL.revokeObjectURL(originalURL); originalURL = null; file.value = '';
    });

    function clearOutput() { outBox.hidden = true; outImg.src = ''; btnDownload.disabled = true; outputBlob = null; }
  </script>
</body>

</html>